\documentclass[10pt,twoside]{article}

\newcommand{\reporttitle}{Levels 1-6}
\newcommand{\reportauthora}{Ayush Bansal}
\newcommand{\reportauthorb}{Aman Deep Singh}
\newcommand{\reportauthorc}{Gunjan Jalori}
\newcommand{\reporttype}{Solutions Report}
\newcommand{\cida}{160177}
\newcommand{\cidb}{15807084}
\newcommand{\cidc}{170283}

% include files that load packages and define macros
\input{includes} % various packages needed for maths etc.
\input{notation} % short-hand notation and macros

%\setlength{\parskip}{0pt}
%\setlength{\parsep}{0pt}
%\setlength{\topskip}{0pt}
%\setlength{\topmargin}{0pt}
%\setlength{\partopsep}{0pt}
%%\setlength\lineskip{0pt}
%\linespread{0.5}
%\setlength{\textfloatsep}{2pt}
%\setlength{\intextsep}{2pt}

%\setlength\itemsep{0em}

\newcommand{\myth}[1]{\textcolor{red}{\hl{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
% front page
\input{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% Main document
\section{Chapter 1 (The Entry)}

There are 5 sub-levels in the chapter, first 4 of these don't have any cipher which needs to be decrypted. \newline

The last sub-level is a \textbf{Substitution Cipher}, the answer to - ``how it was recognised and solved" is explained in the subsection after the following list of commands. \newline

Below is the solution to each of the sub-levels:
\begin{enumerate}
  \setlength\itemsep{0em}
  \item go
  \item read
  \item enter
  \item read
  \item cyLe70Lecy
\end{enumerate}

\subsection{Substitution Cipher}

The ciphertext given was: \newline

\texttt{Nwy dejp pmcplpz cdp sxlrc adegipl ws cdp aejpr. Er nwy aem rpp cdplp xr mwcdxmv ws xmcplprc xm cdp adegipl. Rwgp ws cdp qecpl adegiplr fxqq ip gwlp xmcplprcxmv cdem cdxr wmp, x eg rplxwyr. Cdp awzp yrpz swl cdxr gprrevp xr e rxgbqp ryircxcycxwm axbdpl xm fdxad zxvxcr dejp ippm rdxscpz in 2 bqeapr. Swl cdxr lwymz berrfwlz xr vxjpm ipqwf, fxcdwyc cdp hywcpr.} \newline

For identifying what kind of cipher is applied in the above text, we will use the \textbf{Index of Coincidence}. \newline

The detailed explanation on \textit{Index of Coincidence} can be found in \cref{ic}. \newline

The \textit{Index of Coincidence} of the above ciphertext is about $0.07$, which is approximately same as a valid English text, this suggests that the cipher used is \textit{Mono-alphabetic} such as \textit{Substitution Cipher}. \newline

For Solving the \textit{Substitution Cipher}, the following steps were employed:
\begin{enumerate}
  \setlength\itemsep{0em}
    \item Calculate the frequency of each of the characters in the ciphertext, ignoring anything which is not an english alphabet.
    \item The Character with the highest frequency is most probably `e' or `a', which can be placed in its place and identified further.
    \item As the places get revealed, played hangman to find out what the other characters might be looking at one-letter, 2-letter, 3-letter words with highest number of characters revealed.
    \item Built the decryption key by keeping a map of characters as they are being replaced.
    \item Finally used the decryption key to decrypt the code given for the solution.
\end{enumerate}

The code used in this part is in the file - \texttt{break\_substitution.py}. \newline

The Steps employed in the hangman game and building the key are mentioned below:
\begin{minted}{python}
key = {}
key['p'] = 'e'    # Because 'p' has very high frequency
key['r'] = 's'    # 'r' has very high frequency,
                  #  _ee word exists, matches with "see" not "bee"
key['i'] = 'b'    # _e word exists, matches with "be"
key['n'] = 'y'    # b_ word exists, matches with "by"
key['m'] = 'n'    # bee_ word exists, matches with "been"
key['w'] = 'o'    # _ne word exists, matches with "one"
key['s'] = 'f'    # o_ word exists, 'n' is already taken, matches with "of"
key['l'] = 'r'    # fo_ word exists, matches with "for"
key['y'] = 'u'    # yo_ word exists, matches with "you"
key['g'] = 'm'    # so_e word exists, matches with "some"
key['z'] = 'd'    # use_ word exists, 'r' is already taken, matches with "used"
key['c'] = 't'    # en_ered word exists, matches with "entered"
key['d'] = 'h'    # t_e word exists, matches with "the"
key['x'] = 'i'    # f_rst word and _ (single letter word) exist,
                  # matches with "first" and "i"
key['e'] = 'a'    # single letter word exists, 'i' is already taken, matches with "a"
key['j'] = 'v'    # ha_e word exists, matches with "have"
key['a'] = 'c'    # _hamber word exists, matches with "chamber"
key['v'] = 'g'    # nothin_ word exists, matches with "nothing"
key['f'] = 'w'    # _hich word exists, matches with "which"
key['q'] = 'l'    # be_ow and wi__ word exists, matches with "below" and "will"
key['b'] = 'p'    # sim_le and ci_her word exists, matches with "simple" and "cipher"
key['h'] = 'q'    # _uotes word exists, matches with "quotes"
\end{minted}

The plaintext revealed after using the above decryption key is: \newline

\texttt{You  have  entered  the  first  chamber  of  the  caves.  As  you  can  see  there  is  nothing  of  interest  in  the  chamber.  Some  of  the  later  chambers  will  be  more  interesting  than  this  one,  i  am  serious.  The  code  used  for  this  message  is  a  simple  substitution  cipher  in  which  digits  have  been  shifted  by  2  places.  For  this  round  password  is  given  below,  without  the  quotes.}

\begin{minted}{python}
# For the case of integer digits, "1" must be subtracted from each digit, as mentioned
# text after decryption, it was "2" but it itself was shifted so
# x+x = 2, this gives x = 1
\end{minted}

So, final plaintext is: \newline

\texttt{You  have  entered  the  first  chamber  of  the  caves.  As  you  can  see  there  is  nothing  of  interest  in  the  chamber.  Some  of  the  later  chambers  will  be  more  interesting  than  this  one,  i  am  serious.  The  code  used  for  this  message  is  a  simple  substitution  cipher  in  which  digits  have  been  shifted  by  1  places.  For  this  round  password  is  given  below,  without  the  quotes.} \newline

Using the above decryption key and the logic for digit, we can decipher the code for the answer as well: \newline

Code: \texttt{anQp81Qpan} \newline
Solution: \texttt{cyLe70Lecy}
\newpage
\section{Chapter 2 (The Caveman)}
There are 2 sub-levels in the chapter, first one doesn't have any cipher which needs to be decrypted. \newline

The second sub-level is a \textbf{Vigenere Cipher}, the answer to - ``how it was recognised and solved" is explained in the subsection after the following list of commands. \newline

The detailed explanation on \textit{Vigenere Cipher} can be found in \cref{vc}. \newline

Below is the solution to each of the sub-levels:
\begin{enumerate}
  \setlength\itemsep{0em}
    \item read
    \item the\_cave\_man\_be\_pleased
\end{enumerate}

\subsection{Vigenere Cipher}
The ciphertext given was: \newline

\texttt{Lg ccud qh urg tgay ejbwdkt, wmgtf su bgud nkudnk lrd vjfbg. Yrhfm qvd vng sfuuxytj \newline "vkj\_ecwo\_ogp\_ej\_rnfkukf" wt iq urtuwjm. Ocz iqa jdag vio uzthsivi pqx vkj pgyd encpggt. Uy hopg yjg fhkz arz hkscv ckoq pgfn vu wwygt nkioe zttft djkth.} \newline

For identifying what kind of cipher is applied in the above text, we will use the \textbf{Index of Coincidence}. \newline

The detailed explanation on \textit{Index of Coincidence} can be found in \cref{ic}. \newline

The \textit{Index of Coincidence} of the above ciphertext is about $0.042$, which is closer to the uniform distribution of English text, this suggests that the cipher is \textit{Poly-alphabetic} such as \textit{Vigenere Cipher}, it may be some other Poly-alphabetic cipher as well but we still have to give it a shot. \newline

For solving the \textit{Vigenere Cipher}, the following steps were employed:
\begin{enumerate}
  \setlength\itemsep{0em}
    \item Remove all characters from the text which are not part of the English alphabets and capitilize all characters.
    \item Partition the text according to different key lengths and sort them according to the \textit{Index of Coincidences} achieved, since higher the IC, closer it is to valid English Text.
    \item For each keylen, perform frequency analysis to get the best key possible with the given length.
    \item Try out all the keys retrieved and see which one gives some valid English text.
\end{enumerate}

The code used in this part is in the file - \texttt{break\_vigenere.py}. \newline

The plaintext revealed after using the above decryption key is: \newline

\texttt{Be wary of the next chamber, there is very little joy there. Speak out the password \newline"the\_cave\_man\_be\_pleased" to go through. May you have the strength for the next chamber. To find the exit you first will need to utter magic words there.} \newline

From the above, the solution is revealed: \texttt{the\_cave\_man\_be\_pleased}.

\newpage
\section{Chapter 3 (The Holes)}
There are 4 sub-levels in the chapter, first 3 of these don't have any cipher but there are different tricks which need to be employed to get to the final sub-level. \newline

The last sub-level is a \textbf{Permutation-Substitution Cipher}, the answer to - ``how it was recognised and solved" is explained in the subsection after the following list of steps/commands. \newline

Below are the solution steps to get out of the final chamber:
\begin{enumerate}
  \setlength\itemsep{0em}
  \item Type \texttt{enter} to go to sub-level 2.
  \item At sub-level 2, you try to \texttt{put} your hand in the small hole, it is bitten, denoting there is someone there.
  \item Type \texttt{enter} to go to sub-level 3, here there are a lot of mushrooms growing on the ground.
  \item Type \texttt{pick} to pluck some mushrooms and come back to sub-level 2.
  \item Type \texttt{give} to give the mushrooms to whatever is there in the small hole.
  \item There is a spirit here, who gives you the code \texttt{thrnxxtzy} which can reveal a hidden door at the entrance chamber (sub-level 1).
  \item Go back to sub-level 1 and type \texttt{thrnxxtzy}, this reveals a hidden door with a glass panel beside it.
  \item Type \texttt{read} to get the ciphertext and code.
  \item Type \texttt{jyg\_izuqo\_rr}, which is the decoded plaintext from the cipher provided.
\end{enumerate}

\subsection{Permutation-Substitution Cipher}
The ciphertext given was: \newline

\texttt{cpiftgt ef oldo ukuq vtyp vv ptttqkk dp txe tkcnmbi uxkfft ueukwuqe ad uwv ttdo. da tocwc, qqc qgcu woyg cx cpifteud wat tvkbd vu owk zelc dp txe vthr uccfgg. keb dteuof ut gle dzcc rtc wv ukkyyc xxuo edw. mqgu zec dtyac uldw cqev evyu xvo tee moo mt gle dkcur. tm evyoi qtzc cxz o mlcuauoc, vw wetd kkcc gwhego! cf da foedokm, aibet ccd ktbfkqyo:} \newline

For identifying what kind of cipher is applied in the above text, we used the following techniques:

\begin{itemize}
  \setlength\itemsep{0em}
  \item The \textbf{Index of Coincidence} of the above ciphertext is about $0.057$, which is very close to that of valid English text, this suggests that the cipher used is \textit{Mono-alphabetic} such as \textit{Substitution Cipher}, the detailed explanation on \textit{Index of Coincidence} can be found in \cref{ic}.
  \item The \textbf{Chi-squared Statistic} of the above ciphertext is about $157$ against \textit{uniform distribution}, this suggests that the cipher used is \textit{not Poly-alphabetic} since it is not closer to uniform distribution, the detailed explanation on \textit{Chi-squared Statistic} can be found in \cref{chi}.
  \item The \textbf{Chi-squared Statistic} of the above ciphertext is about $958$ against \textit{valid English text}, this suggests that the cipher used is \textbf{not} a \textit{Simple Permutation} of letters.
  \item Based on the above, we try out different forms of \textit{Mono-alphabetic} ciphers first instead of \textit{Poly-alphabetic}.
\end{itemize}

Firstly, we will try to solve the cipher assuming it is \textit{Simple Substitution Cipher}. This doesn't seem to work, since we are not able to get any valid English text from it. \newline

The code for solving the Substitution Cipher uses the \textbf{n-gram} approach and it is in the file: \texttt{ngram\_score.py}. \newline

Since a \textit{Simple Substitution Cipher} doesn't work here, it could be some other form of \textit{Mono-alphabetic} cipher. \newline

Lets make some observations about the ciphertext:
\begin{itemize}
  \setlength\itemsep{0em}
    \item The occurrences of double letter phrases in words is very frequent and at very odd places, see the below text: \newline
      \texttt{cpiftgt ef oldo ukuq vtyp \myth{vv} p\myth{ttt}q\myth{kk} dp txe tkcnmbi uxk\myth{ff}t ueukwuqe ad uwv \myth{tt}do. da tocwc, \myth{qq}c qgcu woyg cx cpifteud wat tvkbd vu owk zelc dp txe vthr u\myth{cc}f\myth{gg}. keb dteuof ut gle dz\myth{cc} rtc wv u\myth{kkyy}c \myth{xx}uo edw. mqgu zec dtyac uldw cqev evyu xvo t\myth{ee} m\myth{oo} mt gle dkcur. tm evyoi qtzc cxz o mlcuauoc, vw wetd \myth{kkcc} gwhego! cf da foedokm, aibet \myth{cc}d ktbfkqyo:}
    \item The character `o' appears as a single letter, if we assume it to be `a' or `i' (according to english text), then the word `moo' will coincide to `\_aa' or `\_ii' which will not come out to be a valid English word.
    \item A simple substitution solver doesn't give us a valid result for the ciphertext.
\end{itemize}

The above observations suggest the following things:
\begin{itemize}
  \setlength\itemsep{0em}
    \item The letters in the ciphertext needs to be permuted before applying Substitution, this permutation can be a block permutation or matrix permutation or maybe something entirely different.
    \item The cipher is \textit{Poly-alphabetic} (less-likely).
\end{itemize}

Firstly, we will try out \textbf{block-permutation} along with \textbf{Substitution}, i.e. \textbf{Simple Permutation-Substitution Cipher}. \newline

For solving the \textit{Simple Permutation-Substitution Cipher}, the following steps were employed:
\begin{enumerate}
  \setlength\itemsep{0em}
    \item Remove all characters from the text which are not part of the English alphabets, noting their position in the text since they will have to be added back at the end.
    \item Calculate the \textit{block length} (for permutation) using the idea that block length will be a \textit{factor of the total number of characters}.
    \item For each permutation get the permutated text from the ciphertext, and insert all the special characters at their designated places in the text.
    \item Apply a Simple Substitution Cipher Solver to the text and see whether it gives a valid English Text.
    \item If no permutation gives a successful result, try other block length till we reach some valid English Text or run out of factors.
\end{enumerate}

The code used in this part is in the file - \texttt{break\_perm-subs.py}. \newline

The \textit{total number of characters} in the ciphertext is $270$.

Another observation to make here is that the code to be deciphered: \texttt{uhs\_xafmf\_no} has total of $10$ characters.

This suggests that the block length will be a factor of both $270$ and $10$, so it can be $2$, $5$ or $10$, and we will try each of these one by one. \newline

Using the method described above, we got each permutation of ciphertext corresponding to block-length $2$ first, but none of them returned a valid English text after solving the Substitution, so we changed block-length to $5$. \newline

Using block-length $5$ revealed the following plaintext after a certain permutation of ciphertext was solved using Substitution Cipher Solver: \newline

\texttt{breaker of this code will be blessed by the squeaky spirit residing in the hole. go ahead, and find away of breaking the spell on him cast by the evil jaffar. the spirit of the cave man is always with you. find the magic wand that will let you out of the caves. it would make you a magician, no less than jaffar! to go through, speak the password:} \newline

At this point, we got a valid English text from the ciphertext, so we won't be moving forward and trying out different block-length or other ciphers. \newline

Using the permutation and decryption key retrieved from solving above cipher, we can decipher the code for the answer as well: \newline

The decryption key retrieved from the Solver gave us $2$ possible solutions, since we did not have mapping for all $26$ characters: \newline
Code: \texttt{uhs\_xafmf\_no} \newline
Solution $1$: \texttt{jyg\_izuqo\_rr} \newline
Solution $2$: \texttt{jyg\_ixuqo\_rr} \newline

Finally, Solution $1$ was the answer.

\newpage
\section{Chapter 4 (The Spirit)}

This level is tricky as we had to go back to the previous level and perform some task before we could proceed further. \newline

There are 3 sub-tasks here, firstly we have to retrieve a \textit{Magic Wand}, secondly we have to \textit{free the Spirit}, finally solve the \textbf{DES Cipher} to advance to next level. \newline

Below are the solution steps for each of the tasks listed above:
\begin{itemize}
  \setlength\itemsep{0em}
  \item Retrieving the Magic Wand:
    \begin{enumerate}
      \item Type \texttt{enter} to go ahead in the chamber.
      \item Type \texttt{dive} to take a dive into the lake.
      \item At this point, we see an object looking like a wand, but trying to pull it directly causes us to drown, so first go back to surface and take a deep breath.
      \item Type \texttt{dive} and \texttt{pull} the wand.
    \end{enumerate}
  \item Freeing the Spirit:
    \begin{enumerate}
        \item At this point, we can't figure out any way out, the screen in the chamber door is also blank and wand does not help us here.
        \item We can recall that there was an old man/spirit before who helped us in chamber 3 and mentioned that he was trapped by someone, he could be freed by the magic wand.
        \item We go back to chamber 3, \texttt{wave} our wand infront of the hole where the old man's spirit was.
        \item The spirit is freed and says that he will help us along the way.
    \end{enumerate}
  \item Solving the \textbf{DES Cipher}:
    \begin{enumerate}
      \item After entering the 4th chamber, type \texttt{read}.
        \item The screen is still blank, but the spirit tells us what is supposed to be there: \newline
          \texttt{This is a magical screen. You can whisper something close to the screen and the corresponding coded text would appear on it after a while. So go ahead and try to break the code! The code used for this is a 4-round DES, so it should be easy for you!! Er wait ... maybe it is a 6-round DES ... sorry, my memory has blurred after so many years. But I am sure you can break even 6-round DES easily. A 10-round DES is a different matter, but this one surely is not 10-round ...(long pause) ... at least that is what I remember. One thing that I surely remember is that you can see the coded password by whispering 'password'. There was something funny about how the text appears, two letters for one byte or something like that. I do not recall more than that. I am sure you can figure it out though ...}
    \end{enumerate}
\end{itemize}

\subsection{3-Round DES Cipher}

Earlier, we were trying to figure out how many rounds of DES Cipher is applied here, so that we can devise the algorithm for the same. \newline

The task became easier when a hint was revealed stating that the DES Cipher is \textit{3 Round}. \newline

We will break \textit{3 Round DES} using \textbf{Differential Cryptanalysis} as we had discussed in class. \newline

The idea behind \textit{Differential Cryptanalysis} was to get rid of the unknown value (i.e. the Key) so that an equation can be formed over the non-linear step (i.e. sBoxes). \newline

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{des.pdf}
  \label{3-des}
  \caption{3 Round DES}
\end{figure}

Important points about the figure above:
\begin{itemize}
  \setlength\itemsep{0em}
  \item \textit{Double Red Line} implies we know both individual values of \textit{Differential Cryptanalysis}.
  \item \textit{Single Golden Line} implies we know the differential value of 2 inputs, not the individual values themselves.
  \item The pairs of inputs taken during Differential Cryptanalysis must have equal 32 bits on the right side.
\end{itemize}

Solving 3 Round DES:
\begin{enumerate}
  \setlength\itemsep{0em}
    \item We will start by figuring out the 48-bit Key for the 3rd Round.
    \item We know the differential value, just after and before the S-Boxes, thus, there will be 4 possible pairs of input values to the S-Box as studied in class.
    \item This narrows down the search for key over each 6 bits to 4 possibilities.
    \item We will pick another input here, take the intersection of possibilities and narrow down the key.
    \item After sufficient tries, we get the 48-bit 3rd round key.
    \item Now only 8 bits of the key remain, these can be easily brute-forced and figured out using the other round values.
\end{enumerate}

The code used in this part is as follows:
\begin{itemize}
  \setlength\itemsep{0em}
  \item \texttt{constants.py}: Contains the constants for the DES.
  \item \texttt{des.py}: Defines the DES Class encoding all the functions related to it.
  \item \texttt{utils.py}: Defines the common utility functions related to DES and Key generation.
  \item \texttt{break\_des.py}: Defines the main function which uses all the utilities and DES class to break the 3 Round DES according the steps described above.
  \item \texttt{generate\_input.py}: Generates a pair of input which have equal 32 bits on the right side.
\end{itemize}

The key retrieved for the 3rd round of the DES is as follows:
$$\texttt{[61, 28, 9, 54, 55, 9, 28, 51]}$$

here, each value represents the 6-bits of the 48-bit key. \newline 

After doing brute force on the remaining part of the key, we get the following value:
$$147$$

The Final Key (64-bit including the parity bits) for the DES is as follows:
$$0111101001011100001010000011011011110010011010100110101011101000$$

The encrypted password: \texttt{gnushmilfrplulktkrtrogltjojfqjpt} \newline
The decrypted password: \texttt{rirfiirqnujpopirgkholonsqntpkqqi}

\newpage
\section{Chapter 5 (The Fall)}
This level is a bit similar to last one in the way of decoding the cipher, our \textit{Magic Wand} will come handy in this level. \newline

There are 6 sub-levels in the chapter, first 5 of these don't have any cipher but there are trick which needs to be employed to reach the final sub-level. \newline

The last sub-level is an \textbf{AES-type Cipher}, the answer to - ``how it was recognised and solved" is explained in the subsection after the following list of steps/commands. \newline

Below is the solution to each of the sub-levels:
\begin{enumerate}
  \setlength\itemsep{0em}
  \item \texttt{go} further in the passage as you enter the chamber 5.
  \item \texttt{wave} your wand as you begin to fall, as anything else will lead to your death as you reach the end.
  \item \texttt{dive} into the water, as there is nothing around you but water.
  \item \texttt{go} further into the passage you reach after diving into the water.
  \item \texttt{read} the glass panel beside the closed door. \newline
\end{enumerate}

Once we reach the sub-level 6, we get the following information from the spirit about what's written on the screen:

\texttt{"This is another magical screen. And this one I remember perfectly... Consider a block of size 8 bytes as 8 x 1 vector over F\_{128} - constructed using the degree 7 irreducible polynomial x\^7 + x + 1 over F\_2. Define two transformations: first a linear transformation given by invertible 8 x 8 key matrix A with elements from F\_{128} and second an exponentiation given by 8 x 1 vector E whose elements are numbers between 1 and 126. E is applied on a block by taking the ith element of the block and raising it to the power given by ith element in E. Apply these transformations in the sequence EAEAE on the input block to obtain the output block. Both E and A are part of the key. You can see the coded password by simply whispering 'password' near the screen..."}

\subsection{AES-type Cipher}

Firstly, lets talk discuss some observations made about the problem:
\begin{itemize}
  \setlength\itemsep{0em}
  \item Each element of the input $8x1$ vector is part of the finite polynomial field $F_{128}$, so each element (byte) will lie between $0$ and $127$ (both inclusive).
  \item The input and output is encoded as in last level, i.e. one byte is represented by 2 characters, each lying between \texttt{'f'} and \texttt{'u'}. If byte value is 123, then its encoded value will be - \texttt{'mq'}.
  \item Exponentiation process has a $8x1$ vector, each element of the input is raised to corresponding power in the vector, the elements of this exponent vector will lie between $1$ and $126$ (both inclusive).
  \item Linear Transformation Matrix $A$ will be an $8x8$ matrix with each element from the finite polynomial field $F_{128}$, so each element will lie between $0$ and $127$ (both inclusive).
  \item Exponentiation is a byte to byte operation and this operation is independent for each byte.
  \item Linear Transformation is a mixed byte type operation and the mixing will depend on the actual values of the Matrix.
  \item Both $A$ and $E$ are unknown to us and direct brute-force for the solution would require approx. $128^{72}$ or $2^{504}$ computations. \newline
\end{itemize}

For breaking the cipher, we will perform the \textbf{Chosen Plaintext Attack} on the cipher. \newline

Before moving towards the actual solution, we will prove the following:
\begin{itemize}
  \setlength\itemsep{0em}
  \item Matrix $A$ is \textbf{Lower Triangular Matrix}.
  \item In the $8x1$ output vector, $i^{th}$ byte will depend on all bytes upto $(i-1)^{th}$ byte of the input, i.e. changing $i^{th}$ byte of input will change all bytes from $i^{th}$ to the $8^{th}$ byte of output. \newline
\end{itemize}

\begin{lemma} \label{lem:1}
  Matrix $A$ is \textbf{Lower Triangular Matrix}
\end{lemma}

\begin{proof}
  Suppose the matrix $A$ is as follows:
  $$\begin{bmatrix}
    a_1 & a_2 & a_3 & a_4 & a_5 & a_6 & a_7 & a_8\\
    b_1 & b_2 & b_3 & b_4 & b_5 & b_6 & b_7 & b_8\\
    c_1 & c_2 & c_3 & c_4 & c_5 & c_6 & c_7 & c_8\\
    d_1 & d_2 & d_3 & d_4 & d_5 & d_6 & d_7 & d_8\\
    e_1 & e_2 & e_3 & e_4 & e_5 & e_6 & e_7 & e_8\\
    f_1 & f_2 & f_3 & f_4 & f_5 & f_6 & f_7 & f_8\\
    g_1 & g_2 & g_3 & g_4 & g_5 & g_6 & g_7 & g_8\\
    h_1 & h_2 & h_3 & h_4 & h_5 & h_6 & h_7 & h_8
  \end{bmatrix}$$

  \textbf{Part 1:} Using the \textbf{eighth} byte. \newline

  Since, we are performing a chosen plaintext attack, lets take inputs of the following format:
  $$ffffffffffffffXX$$
  here, $XX$ will be a non-zero byte value i.e. from $1$ to $127$ (both inclusive). \newline

  The ciphertext for the above plaintext format comes out to be:
  $$ffffffffffffffXX$$
  All first seven bytes remain zero ($ff$), even though the last byte of the input was non-zero, this is true for any value of the eighth byte. \newline

  The $8x1$ vector retreived after performing the first \textit{Linear Transformation} will be as follows:
  $$\begin{bmatrix}
    a_8\cdot v & b_8\cdot v & c_8\cdot v & d_8\cdot v & e_8\cdot v & f_8\cdot v & g_8\cdot v & h_8\cdot v
  \end{bmatrix}^T$$
  here, $v$ is the value of the eighth byte of Exponentiation. \newline

  The value of first seven bytes must result in zero for all possible input values of eighth byte, this will be true only if the \textbf{first seven values of the last column of A are zero}. \newline

  So, the updated matrix $A$ will be as follows:
  $$\begin{bmatrix}
    a_1 & a_2 & a_3 & a_4 & a_5 & a_6 & a_7 & 0\\
    b_1 & b_2 & b_3 & b_4 & b_5 & b_6 & b_7 & 0\\
    c_1 & c_2 & c_3 & c_4 & c_5 & c_6 & c_7 & 0\\
    d_1 & d_2 & d_3 & d_4 & d_5 & d_6 & d_7 & 0\\
    e_1 & e_2 & e_3 & e_4 & e_5 & e_6 & e_7 & 0\\
    f_1 & f_2 & f_3 & f_4 & f_5 & f_6 & f_7 & 0\\
    g_1 & g_2 & g_3 & g_4 & g_5 & g_6 & g_7 & 0\\
    h_1 & h_2 & h_3 & h_4 & h_5 & h_6 & h_7 & h_8
  \end{bmatrix}$$

  \textbf{Part 2:} Using the \textbf{seventh} byte. \newline

  Now, lets take input of the following format:
  $$ffffffffffffXXff$$

  The ciphertext for the above plaintext format comes out to be:
  $$ffffffffffffXXXX$$

  First six bytes remain zero ($ff$), even though the seventh byte of the input was non-zero, this is true for any value of the seventh byte. \newline

  The $8x1$ vector retreived after performing the first Linear Transformation will be as follows:
  $$\begin{bmatrix}
    a_7\cdot v & b_7\cdot v & c_7\cdot v & d_7\cdot v & e_7\cdot v & f_7\cdot v & g_7\cdot v & h_7\cdot v
  \end{bmatrix}^T$$
  here, $v$ is the value of the seventh byte of Exponentiation. \newline

  The value of first six bytes must result in zero for all possible input values of seventh byte, this will be true only if the \textbf{first six values of the seventh column of A are zero}. \newline

  So, the updated matrix $A$ will be as follows:
  $$\begin{bmatrix}
    a_1 & a_2 & a_3 & a_4 & a_5 & a_6 & 0 & 0\\
    b_1 & b_2 & b_3 & b_4 & b_5 & b_6 & 0 & 0\\
    c_1 & c_2 & c_3 & c_4 & c_5 & c_6 & 0 & 0\\
    d_1 & d_2 & d_3 & d_4 & d_5 & d_6 & 0 & 0\\
    e_1 & e_2 & e_3 & e_4 & e_5 & e_6 & 0 & 0\\
    f_1 & f_2 & f_3 & f_4 & f_5 & f_6 & 0 & 0\\
    g_1 & g_2 & g_3 & g_4 & g_5 & g_6 & g_7 & 0\\
    h_1 & h_2 & h_3 & h_4 & h_5 & h_6 & h_7 & h_8
  \end{bmatrix}$$

  \textbf{Part 3:} Generalizing for the rest of the bytes. \newline
  
  Taking the following byte formats one at a time and performing the same steps we did above, we get the following ciphertext formats:
  \begin{align*}
    EAEAE(ffffffffffXXffff) &= ffffffffffXXXXXX \\
    EAEAE(ffffffffXXffffff) &= ffffffffXXXXXXXX \\
    EAEAE(ffffffXXffffffff) &= ffffffXXXXXXXXXX \\
    EAEAE(ffffXXffffffffff) &= ffffXXXXXXXXXXXX \\
    EAEAE(ffXXffffffffffff) &= ffXXXXXXXXXXXXXX
  \end{align*} \newline

  Performing the same calculations, the finally updated matrix $A$ that we receive will be as follows:
  \begin{align}
    \begin{bmatrix}
    a_1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
    b_1 & b_2 & 0 & 0 & 0 & 0 & 0 & 0\\
    c_1 & c_2 & c_3 & 0 & 0 & 0 & 0 & 0\\
    d_1 & d_2 & d_3 & d_4 & 0 & 0 & 0 & 0\\
    e_1 & e_2 & e_3 & e_4 & e_5 & 0 & 0 & 0\\
    f_1 & f_2 & f_3 & f_4 & f_5 & f_6 & 0 & 0\\
    g_1 & g_2 & g_3 & g_4 & g_5 & g_6 & g_7 & 0\\
    h_1 & h_2 & h_3 & h_4 & h_5 & h_6 & h_7 & h_8
    \end{bmatrix} \label{eq:1}
  \end{align}

  The above matrix is a \textbf{Lower Triangular Matrix}.
\end{proof}

\begin{lemma} \label{lem:2}
  In the $8x1$ output vector, $i^{th}$ byte will depend on all bytes upto $(i-1)^{th}$ byte of the input, i.e. changing $i^{th}$ byte of input will change all bytes from $i^{th}$ to the $8^{th}$ byte of output.
\end{lemma}

\begin{proof}
  The Matrix $A$ will be as defined in \cref{eq:1}. \newline

  Let the input $8x1$ vector be as follows:
  $$\begin{bmatrix}
    i_1 & i_2 & i_3 & i_4 & i_5 & i_6 & i_7 & i_8
  \end{bmatrix}^T$$

  After applying the Linear Transformation using the matrix $A$, we will get the following $8x1$ vector:
  $$\begin{bmatrix}
    (a_1\cdot i_1) \\
    (b_1\cdot i_1) + (b_2\cdot i_2) \\
    (c_1\cdot i_1) + (c_2\cdot i_2) + (c_3\cdot i_3) \\
    (d_1\cdot i_1) + (d_2\cdot i_2) + (d_3\cdot i_3) + (d_4\cdot i_4)\\
    (e_1\cdot i_1) + (e_2\cdot i_2) + (e_3\cdot i_3) + (e_4\cdot i_4) + (e_5\cdot i_5)\\
    (f_1\cdot i_1) + (f_2\cdot i_2) + (f_3\cdot i_3) + (f_4\cdot i_4) + (f_5\cdot i_5) + (f_6\cdot i_6)\\
    (g_1\cdot i_1) + (g_2\cdot i_2) + (g_3\cdot i_3) + (g_4\cdot i_4) + (g_5\cdot i_5) + (g_6\cdot i_6) + (g_7\cdot i_7)\\
    (h_1\cdot i_1) + (h_2\cdot i_2) + (h_3\cdot i_3) + (h_4\cdot i_4) + (h_5\cdot i_5) + (h_6\cdot i_6) + (h_7\cdot i_7) + (h_8\cdot i_8)
  \end{bmatrix}$$

  The above matrix clearly implies that first byte is independent of other bytes, second byte depends on first byte and itself, third byte depends on first, second bytes and itself and so on. \newline

\end{proof}

Now, we have established certain properties about Linear Transformation and Exponentiation, we can move on to cracking password and breaking the cipher. \newline

Firstly, we will just decode the ciphertext of the password and get the corresponding plaintext without finding the actual values of the matrix $A$ and exponent $E$. \newline

Nextly, we will use \textit{Chosen Plaintext Attack} to retrieve the values of $A$ and $E$.

\subsubsection{Cracking Password}
We will make use of the result of \cref{lem:2}. \newline

Given a 8-byte ciphertext, we will determine the plaintext bytes one-by-one beginning from the first byte. \newline

The Algorithm used is as follows:
\begin{enumerate}
  \setlength\itemsep{0em}
  \item Divide the password into chunks of 8 bytes, if last chunk is not complete 8 bytes then pad it with zeroes ($ff$), and solve each chunk separately.
  \item Initialize \texttt{known\_plaintext} as an empty string, since nothing is known right now.
  \item For each ($i^{th}$) byte of the ciphertext, do the following:
    \begin{enumerate}
      \setlength\itemsep{0em}
      \item Enumerate over all possibilities of byte values - $0$ to $127$, let this value be \texttt{current\_byte}.
      \item Generate a plaintext as - \texttt{known\_plaintext + current\_byte + padding}, here padding will be applied to make the input plaintext 8 bytes.
      \item Get the corresponding ciphertext, let it's $i^{th}$ byte be \texttt{cipher\_byte}.
      \item If \texttt{cipher\_byte} is equal to the $i^{th}$ byte of the input ciphertext, then update \texttt{known\_plaintext = known\_plaintext + current\_byte}.
      \item Go to next iteration of Step 3.
    \end{enumerate}
\end{enumerate}

The above algorithm uses the fact that first byte is independent of all other bytes, so it can be directly found. \newline

Once the first byte is found, it can be kept constant and second byte can be found using the same method, this continues for the rest of the bytes. \newline

The number of computations performed in the above algorithm will be $128\cdot 8$ or $2^{10}$. \newline

The code for the above algorithm can be found in \texttt{decrypt\_password.py}. \newline

The password given was: \texttt{ktirlqhtlqijmmhqmgkplijngrluiqlq} \newline
The plaintext solved is: \texttt{lhlgmjmkmglqlompmoltmglilqlmlgmh} \newline

Directly adding the plaintext as the result, didn't advance us to the next level. \newline
The ciphertext didn't have multiple plaintexts corresponding to it as well. \newline

We thought that the input is an 8-byte value which is actually represented as 16 characters, and we tried printing the value of each byte which was represented by the plaintext: \newline

The plaintext solved was: \texttt{lhlgmjmkmglqlompmoltmglilqlmlgmh} \newline
The byte values were: \newline
\texttt{[98, 97, 116, 117, 113, 107, 105, 122, 121, 110, 113, 99, 107, 103, 97, 114]} \newline

Surprisingly, all byte values lie within the range of ascii values of \texttt{'a'} and \texttt{'z'}. \newline

Finally, we tried the string generated by getting the ascii values of each of the above bytes, and this was the final answer. \newline

Final Result was: \texttt{batuqkizynqckgar}

\subsubsection{Solving for $A$ and $E$}
A and E comprise the key of this encryption algorithm.\\
Using \cref{lem:1}, we know that A is a lower triangular matrix.\\
Let the input $8x1$ vector be as follows
  $$\begin{bmatrix}
    i_1 & i_2 & i_3 & i_4 & i_5 & i_6 & i_7 & i_8
  \end{bmatrix}^T$$
Let the E $8x1$ vector be as follows

  $$\begin{bmatrix}
    e_1 & e_2 & e_3 & e_4 & e_5 & e_6 & e_7 & e_8
  \end{bmatrix}^T$$

Let the A $8x8$ matrix be as follows

  $$\begin{bmatrix}
    a_{(1,1)} & 0 & 0 & 0 & 0 &0 &0 &0\\
a_{(2,1)} & a_{(2,2)} & 0 & 0 & 0 &0 &0 &0 \\
a_{(3,1)} & a_{(3,2)} & a_{(3,3)} & 0 & 0 &0 &0 &0 \\
a_{(4,1)} & a_{(4,2)} & a_{(4,3)} & a_{(4,4)} & 0 &0 &0 &0 \\
a_{(5,1)} & a_{(5,2)} & a_{(5,3)} & a_{(5,4)} & a_{(5,5)} &0 &0 &0 \\
a_{(6,1)} & a_{(6,2)} & a_{(6,3)} & a_{(6,4)} & a_{(6,5)} &a_{(6,6)} &0 &0 \\
a_{(7,1)} & a_{(7,2)} & a_{(7,3)} & a_{(7,4)} & a_{(7,5)} &a_{(7,6)} &a_{(7,7)} &0 \\
a_{(8,1)} & a_{(8,2)} & a_{(8,3)} & a_{(8,4)} & a_{(8,5)} &a_{(8,6)} &a_{(8,7)} &a_{(8,8)}
  \end{bmatrix}$$
  
The output of the first exponentiation will be
  $$\begin{bmatrix}
    i_1^{e_1} & i_2^{e_2} & i_3^{e_3} & i_4^{e_4} & i_5^{e_5} & i_6^{e_6} & i_7^{e_7} & i_8^{e_8}
  \end{bmatrix}^T$$

The output of the first linear transform will be
  $$\begin{bmatrix}
    (a_{(1,1)}\cdot i_1^{e_1}) \\
    (a_{(2,1)}\cdot i_1^{e_1}) + (a_{(2,2)}\cdot i_2^{e_2}) \\
    (a_{(3,1)}\cdot i_1^{e_1}) + (a_{(3,2)}\cdot i_2^{e_2}) + (a_{(3,3)}\cdot i_3^{e_3}) \\
    (a_{(4,1)}\cdot i_1^{e_1}) + (a_{(4,2)}\cdot i_2^{e_2}) + (a_{(4,3)}\cdot i_3^{e_3}) + (a_{(4,4)}\cdot i_4^{e_4})\\
    (a_{(5,1)}\cdot i_1^{e_1}) + (a_{(5,2)}\cdot i_2^{e_2}) + (a_{(5,3)}\cdot i_3^{e_3}) + (a_{(5,4)}\cdot i_4^{e_4}) + (a_{(5,5)}\cdot i_5^{e_5})\\
    (a_{(6,1)}\cdot i_1^{e_1}) + (a_{(6,2)}\cdot i_2^{e_2}) + (a_{(6,3)}\cdot i_3^{e_3}) + (a_{(6,4)}\cdot i_4^{e_4}) + (a_{(6,5)}\cdot i_5^{e_5}) + (a_{(6,6)}\cdot i_6^{e_6})\\
    (a_{(7,1)}\cdot i_1^{e_1}) + (a_{(7,2)}\cdot i_2^{e_2}) + a_{(7,3)}\cdot i_3^{e_3}) + (a_{(7,4)}\cdot i_4^{e_4}) + (a_{(7,5)}\cdot i_5^{e_5}) + (a_{(7,6)}\cdot i_6^{e_6}) + (a_{(7,7)}\cdot i_7^{e_7})\\
    (a_{(8,1)}\cdot i_1^{e_1}) + (a_{(8,2)}\cdot i_2^{e_2}) + (a_{(8,3)}\cdot i_3^{e_3}) + (a_{(8,4)}\cdot i_4^{e_4}) + (a_{(8,5)}\cdot i_5^{e_5}) + (a_{(8,6)}\cdot i_6^{e_6}) + (a_{(8,7)}\cdot i_7^{e_7}) + (a_{(8,8)}\cdot i_8^{e_8})
  \end{bmatrix}$$
Observe that if the input $8x1$ vector has only one non zero block $i_k$, then the output blocks upto index $k-1$ will be zero. $k_{th}$ block of output is $\big(a_{(k,k)}\cdot(a_{(k,k)}\cdot{i_k}^{e_k})^{e_k}\big)^{e_k}$. The $k^{th}$ block of the output will depend only on $i_k, e_k  $ and $a_{(k, k)}$[$(k,k)^{th}$ element in $A$].\\


So, for each $k \in \{1,2,3,4,5,6,7,8\}$ multiple inputs are considered where only the $k^{th}$ block is non-zero and takes all possible values in $[0, 127]$. For each such input, $k^{th}$ block of the output is considered.  Using such pairs, we calculate possible values of $e_k$ and $a_{(k,k)}$ by iterating through all possible values of $e_k$ and $a_{(k,k)}$ and considering those which which provide correct input to output transform.\\
% \begin{center}
    

% \begin{tabular}{|c|c|c|}
%     \hline
%     k & Possible values of $e_k$ & Possible values of $a_{(k,k)}$\\
%     \hline
%     1 & &\\
%     2 & &\\
%     3 & &\\
%     4 & &\\
%     5 & &\\
%     6 & &\\
%     7 & &\\
%     8 & &\\
%     \hline
% \end{tabular}
% \end{center}

Now the task is do minimize this set of possible values of $e_k$ and  $a_{(k,k)}$ to get unique values. Also we need to find non-diagonal elements of $A$.\\


Consider the $k^{th}$ block of output when only the $j^{th}$ block of input is non-zero($k > j$). $k_{th}$ block of output is $\big(a_{(k,j)}\cdot(a_{(j,j)} \cdot i_j^{e_j})^{e_j} + a_{(k,k)}\cdot(a_{(k,j)} \cdot i_j^{e_j} )^{e_k} \big)^{e_k}$. The $k^{th}$ block of the output will depend on only $e_j, e_k, a_{(k,k)}, a_{(j, j)}, a_{(k, j)}$.\\


Because we know a reduced set of possible values of $e_j, e_k, a_{(k,k)}, a_{(j, j)}$, we can get possible values of $a_{(k, j)}$ by considering plaintexts where $j^{th}$ block of input is non-zero and considering $k^{th}$ block of the corresponding ciphertext and iterating over all possible values of $a_{(k, j)}$ and considering only those which provide correct input to output transform.
Also, we remove values of $e_j$'s, $e_k$'s, $a_{(j,j)}$'s  and $a_{(k,k)}$'s which have no such possible value of $a_{(k, j)}$, from the set of possible values of $e_k$'s and $a_{(k,k)}$'s.\\
By doing such calculations for all $j \in \{1,2,3,4,5,6,7\}$ and $k,  \in [j+1, 8]$, we get unique values all non-diagonal elements of $A$. We also get unique values of diagonal elements of $A$($a_{(k,k)}$'s) and $e_k$'s.\\
We obtain $E$ vector as 
$$\begin{bmatrix}
85 & 52 & 38 & 72& 116& 38& 66& 50
    % e_1 & e_2 & e_3 & e_4 & e_5 & e_6 & e_7 & e_8
  \end{bmatrix}^T$$
 We obtain $A$ matrix as
 
 $$\begin{bmatrix}
 100& 0& 0& 0& 0& 0& 0& 0\\
 122&56& 0& 0& 0& 0& 0& 0\\
 6 &121&40& 0& 0& 0& 0& 0\\
  10&97&77&50& 0& 0& 0& 0\\
  58&14&78&10&16& 0& 0& 0\\
 9&76 &114 &116&92&87& 0& 0\\
 104&30&98&92 &104&44&14& 0\\
  13&91&54&58 &113&17&37 &103
  \end{bmatrix}$$
The code for getting input and output pairs can be found in the script \texttt{getInputOutputPairs.py}.\\

The code for this part can be found in the script \texttt{getKeysandDecrypt.py}.\\
Once we have $E$ and $A$, getting the password was just reduced to bruteforcing over all possible inputs and finding the input corresponding to the encrypted password. The input was then converted to ASCII format and the result was \texttt{batuqkizynqckgar}.

\section{Chapter 6 (RSA Encryption)}

Since we can't access the server during this level, we skipped to the final puzzle of the level which is breaking the \textbf{RSA Encryption} (with small exponent) when you know some significant part of the message.

The problem statement provided to us is as follows:

\begin{itemize}
  \item The public key $(n,e)$ used for the \textbf{RSA Encryption}. \newline
    \texttt{N = 84364443735725034864402554533826279174703893439763343343863260342756678609 \\ 216895093779263028809246505955647572176682669445270008816481771701417554768871 \\ 285020442403001649254405058303439906229201909599348669565697534331652019516409 \\ 514800265887388539283381053937433496994442146419682027649079704982600857517093} \newline
    \texttt{e = 5}
  \item The information about the password and message. \newline
    \texttt{This door has RSA encryption with exponent 5 and the password is} \newline
    \texttt{588511908193557145472758995584417156637461398472460756192707453386570070556983 \\ 787406377427753617688997008888580870506626143183054430644488980265035567576103 \\ 429384907413616436962850518672602785678969919273519645573749776196447636332298 \\ 96668511752432222528159214013173319855645351619393871433455550581741643299}
\end{itemize}

\subsection{Thinking about the Solution} \label{sec:1}

For breaking the encryption, we will perform the \textbf{Coppersmith's Attack (Low Public exponent Attack)} on the password provided to us. \newline

Before moving forward, let's state the famous \textbf{Coppersmith Theorem} as we are going to use it in our results.

\begin{theorem}
  Let $N$ be an integer of unknown factorization, which has a divisor $b \geq N^{\beta}$. Furthermore, let $f_b(x)$ be a univariate, monic polynomial of degree $\delta$. Then we can find all solutions $x_0$ for the equation $f_b(x) = 0 \; (\text{mod} \; b)$ with
$$|x_0| \leq \frac{1}{2}N^{\frac{\beta^2}{\delta}-\epsilon}$$
  in polynomial time in $\left(\text{log}N, \delta, \frac{1}{e}\right)$
\end{theorem}

And a \textit{corollary} which is a direct implication of the above theorem.

\begin{theorem} \label{theorem:2}
  Let $N$ be an integer of unknown factorization, which has a divisor $b \geq N^{\beta}$. Let $f_b(x)$ be a univariate, monic polynomial of degree $\delta$. Furthermore, let $c_N$ be a function that is upper-bounded by a polynomial in $\text{log}N$. Then we can find all solutions $x_0$ for the equation $f_b(x) = 0 \; (\text{mod} \; b)$ with
  $$|x_0| \leq c_N N^{\frac{\beta^2}{\delta}}$$
  in polynomial time in $(\text{log}N, \delta)$.
\end{theorem}

Now, let's get a few fundamentals out of the way, we know that: \newline

Suppose we have the plaintext $m$ and we wish to encrypt it using the public key $(N,e)$, then the ciphertext $c$ will be as follows:
\begin{align}
  c \equiv m^e \; (mod \; N) \label{eq:2}
\end{align}

Now, notice that the problem of decrypting an RSA-encrypted plaintext $c \equiv m^e \; (mod \; N)$ is the problem of finding the unique positive root $x_0 = m < N$ of the polynomial:
\begin{align}
  f_n(x) = x^e - c \; (mod \; N) \label{eq:3}
\end{align}

Under the assumption that inverting the RSA function is hard, we cannot solve this problem in general. \newline

But if we cannot solve the problem for all $m \in \mathbb{Z}_n$, then it might be feasible for especially small values of $m$ (as studied in class). Indeed, it is a well-known protocol failure of RSA that one can recover $m$ in polynomial time whenever $m < N^{\frac{1}{e}}$. The reason why this attack works is simple: \newline

Since $m^e < N$, we have
\begin{align}
  m^e - c = 0 \quad \text{over} \; \; \mathbb{Z} \label{eq:4}
\end{align}

and not just modulo $N$. Thus, we can simply take the $e^{th}$ root of $c$ in order to recover the value of $m$. \newline

Now consider the following problem:

\begin{problem} \label{prob:1}
  Suppose that $m = M + x$ for some known part $M$ of the message and some unknown part $x \leq N^{\frac{1}{e}}$. Can we still recover $m$?
\end{problem}

This situation occurs in the case of so-called \textbf{stereotyped messages}: Assume we already know a part $M$ of the message which is always the same, for example $M$ corresponds to ``Good morning to everybody. Todays session-key is:". But symmetric crypto-schemes often need keys of length at most $80$ bits. Hence, the above situation, where the unknown part $x$ is smaller than the $e^{th}$ root of the modulus $N$ can easily occur in practice when RSA is used with small exponent $e$. \newline

Let's consider a special case of \cref{theorem:2}, $b = N$ and $c_N = 1$, which is provided in the work of Coppersmith \cite{Coppersmith1997}

\begin{theorem} \label{theorem:3}
  Let $N$ be an integer with unknown factorization. Furthermore, let $f_N(x)$ be a univariate, monic polynomial of degree $\delta$. Then we can find all solutions $x_0$ for the equation $f_N(x) = 0 \; (\text{mod} \; N)$ with
  $$|x_0| \leq N^{\frac{1}{\delta}}$$
  in polynomial time in $(\text{log}N, \delta)$.
\end{theorem}

If we apply \textbf{Coppersmith's method} to the above \cref{prob:1}, An application of above \cref{theorem:3} yields the following result.

\begin{lemma} \label{lemma:1}
  Let $(N,e)$ be an RSA public key. Furthermore, let $c := (M + x_0)^e \; (\text{mod} \; N)$ be an RSA-encrypted message with known $M$ and unknown $x_0$, where
  $$x_0 \leq N^{\frac{1}{e}}$$
  Then we can find $x_0$ in polynomial time in $\text{log}N$ and $e$.
\end{lemma}

\begin{proofn}
  Define
  \begin{align}
    f_N(x) := (M + x)^e - c \label{eq:5}
  \end{align}
  which is a univariate monic polynomial of degree $e$ with the small root $x_0$, $x_0 \leq N^{\frac{1}{e}}$ modulo $N$. An application of \cref{theorem:3} proves the claim
\end{proofn}

\subsection{Solution Outline}
We are provided the public key in the problem - $(N, e)$ and the encrypted password $c$. \newline

At this point, we make an assumption that the password $x_0$ we want to recover is small i.e. $x_0 \leq N^{\frac{1}{e}}$, otherwise breaking RSA encryption is not feasible as we discussed in \cref{sec:1}. \newline

If we assume full password $x_0$ as unknown and we know that it is small, then by using \cref{eq:4}, it can be found by taking the $e^{th}$ root of $c$. \newline
But if we try to find the $e^{th}$ root of $c$, we are unsuccessful because it is not a perfect power of $5$ for some integer. \newline

So, we move to solving the \cref{prob:1}. For this we should already know some part of the password and small part will be unknown. \newline

In the problem, we are given the string \texttt{This door has RSA encryption with exponent 5 and the password is}. \newline
At this point, we make a second assumption that this problem is like a \textbf{stereotyped message}. \newline

So, the initial plaintext message will be of the form: \newline
\texttt{This door has RSA encryption with exponent 5 and the password is XXXXXXXX...} \newline

Here, known part of the message is ``\texttt{This door has RSA encryption with exponent 5 and the password is }" and the unknown part is what comes after this. \newline

Now we established the assumptions, let's go through the steps we took to find out the value of $x_0$.

\begin{itemize}
  \setlength\itemsep{0em}
  \item Since RSA works only on integers, we will first convert the known plaintext into hex format (using the corresponding ascii values of characters).
  \item Convert the hex form into the corresponding integer $M_0$.
  \item Iterate from $i=1$ to $i=200$ ($x_0$ can be upto \textasciitilde$200$ bits, by first assumption), for each iteration.
    \begin{itemize}
      \setlength\itemsep{0em}
      \item Left shift the integer $M_0$ by $i$ to get integer $M$.
      \item Solve the \cref{eq:5} modulo $N$ to get the value of small $x_0$.
      \item If a solution exists, convert solution integer $x_0$ to hex format.
      \item Finally, convert the hex format to ascii text and report the result.
    \end{itemize}
\end{itemize}

The solution code for the problem can be found in \texttt{solve.sage}, we used the \textbf{Sage Math} libraries \cite{sagemath} to solve the equation by using the \textbf{Coppersmith's Algorithm} as described in Alexander May's PhD thesis \cite{alex} \newline 

The password retrieved was: \texttt{tkigrdrei}. \newline

Hence, the complete plaintext will be as follows: \newline
\texttt{This door has RSA encryption with exponent 5 and the password is tkigrdrei}

\newpage
\section{Appendix}

This section explains each of the things used in between the solutions without proper explanation.

\subsection{Index of Coincidence} \label{ic}

The \textbf{Index of Coincidence} is a measure of how similar a frequency distribution is to the uniform distribution.
$$ I.C. = \frac{\sum_{i=A}^{i=Z} f_i(f_i-1)}{N(N-1)}$$

where $f_i$ is the count of letter $i$ (where $i = A,B,...,Z$) in the ciphertext, and $N$ is the total number of letters in the ciphertext. \newline

Important facts about the \textit{Index of Coincidence}:
\begin{itemize}
  \setlength\itemsep{0em}
    \item The \textit{Index of Coincidence} of valid English text is about $0.066$.
    \item The \textit{Index of Coincidence} for uniform distribution of English text is about $0.038$.
    \item The \textit{Index of Coincidence} remains the same for the ciphertext and plaintext if cipher is \textbf{Mono-alphabetic} (i.e. Substitution Cipher).
    \item The \textit{Index of Coincidence} of ciphertext is closer to uniform distribution if cipher is \textbf{Poly-alphabetic} (such as Vigenere Cipher).
\end{itemize}

We can get an approximate idea of what kind of cipher is used to generate the ciphertext by using the \textit{Index of Coincidence}.

\subsection{Chi-squared Statistic} \label{chi}
The \textbf{Chi-squared Statistic} is a measure of how similar two categorical probability distributions are. If the two distributions are identical, the chi-squared statistic is 0, if the distributions are very different, some higher number will result. The formula for the chi-squared statistic is:
$$\chi^2(C,E) = \sum_{i=A}^{i=Z}\frac{(C_i-E_i)^2}{E_i}$$

where $C_A$ is the count (not the probability) of letter $A$, and $E_A$ is the expected count of letter $A$. \newline

Important facts about the \textit{Chi-squared Statistic}:
\begin{itemize}
  \setlength\itemsep{0em}
  \item If the \textit{Chi-squared Statistic} of a ciphertext against \textit{uniform distribution} is very low (\textasciitilde 50 or less), then it is highly probable that the cipher is \textit{Poly-alphabetic}.
  \item If the \textit{Chi-squared Statistic} of a ciphertext against \textit{valid English text} is high and the cipher is \textit{Mono-alphabetic}, then it can be solved by trying keys and lowering it.
\end{itemize}

We can get an approximate idea of whether the cipher is \textit{Poly-alphabetic} or not by using \textit{Chi-squared Statistic}.

\subsection{Vigenere Cipher} \label{vc}
The Vigenere Cipher is a polyalphabetic substitution cipher. \newline

Suppose, the length of the encryption key is $k$, then the string formed by picking out each letter with a multiple of $k$ letters in between them will be a \textit{Caesar Cipher}. \newline

Since each such string is a \textit{Caesar Cipher}, the \textit{Index of Coincidence} of this string will be closer to that of valid English text rather than closer to uniform distribution. \newline

Using the above principle, we can crack the \textit{Vigenere Cipher}.

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
